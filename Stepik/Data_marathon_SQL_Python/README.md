## Марафон данных: первое знакомство с SQL и Python
[Ссылка](https://stepik.org/course/105359/syllabus) на курс.
Анализ данных подразумевает поиск каких-либо взаимосвязей в существующих данных компании.  Для этого аналитики строят гипотезы и проверяют их различными способами. Один из самых распространенных методов изучения данных – метрики.
- `Метрики` —  показатели, которые используются для оценки работы различных отделов (маркетинга, продаж и т.д.) или бизнеса в целом, а также успешности продуктов компании.

[Курс Data Марафон](https://docs.google.com/document/d/1lTNa5DINxjoBknKxJT516qnc4dXwwm5E/edit)

- `SELECT` - выбрать

    SELECT DISTINCT event_name FROM game_events
- `DISTINCT` - уникальный, то есть, мы буквально говорим: выбери уникальные значения категорий из таблицы
- `WHERE` - оператор,  который накладывает ограничения на строки.

    SELECT *
    FROM game_events
    WHERE event_name = 'app_first_launch'
<img width="1291" alt="image" src="https://github.com/luta-wolf/luta-wolf/assets/58044383/42ca7e09-776a-404c-aeea-123834afabd2">

Первым всегда будет отрабатывать оператор FROM, потому что перед тем как начинать работать с данными, нам необходимо указать источник этих данных.

После него всегда будет отрабатывать оператор WHERE, так как, после того как мы указали источник данных, нам необходимо его отфильтровать.

И только после того, как мы отфильтровали данные, они передаются в оператор SELECT, и там уже мы сможем выбрать столбцы, которые нам необходимы, и вывести их на экран.

<img width="824" alt="image" src="https://github.com/luta-wolf/luta-wolf/assets/58044383/8e215cd7-dadc-4ed8-9341-9a15f6159ad7">

    Пример написания даты: '2021-01-10', то есть ГОД - МЕСЯЦ - ДЕНЬ.
    Обратите внимание, что дату необходимо указывать в кавычках.

<img width="1113" alt="image" src="https://github.com/luta-wolf/luta-wolf/assets/58044383/8ccbad1b-dfb2-4fb9-a373-e1f64ff46c09">

- `Агрегирующие функции` (иногда их ещё называют агрегатными) обрабатывают набор строк для подсчета и возвращают одно обобщенное значение.

    SELECT COUNT(*)
    FROM game_events

Такой запрос всегда вернет только одно значение – количество строк в таблице, которая указана во `FROM`.
Что происходит под капотом?
`FROM` всегда работает первым, но в `SELECT` у нас написана агрегирующая функция. Эта функция считает количество строк в таблице.
    COUNT(*) – считает количество строк в таблице
    SUM()– считает сумму в рамках столбца
    AVG()– считает среднее в рамках столбца
    MIN()– находит минимальное значение в рамках столбца
    MAX()– находит максимальное значение в рамках столбца


- `COUNT()` считает количество строк, но при этом может работать по-разному в некоторых условиях.
- COUNT(*) – считает количество строк в таблице
- COUNT(level_name) – считает количество заполненных НЕ NULL значений в рамках столбца level_name
- COUNT(DISTINCT level_name) – считает количество уникальных НЕ NULL значений в рамках столбца level_name, это означает, что повторяющиеся значения считаются только один раз
    SELECT COUNT(*), COUNT(level_name), COUNT(DISTINCT level_name)
    FROM game_events

- `SUM()` используется, чтобы посчитать сумму значений в столбце.

    SELECT SUM(revenue)
    FROM game_events
Результатом будет сумма всех значений в столбце revenue.
Используйте `SUM()` с числовым типом данных. Если использовать SUM() со строковым типом данных, программа отработает, но результат работы программы будет не всегда очевидный. Например, если в строке нет чисел, то функция SUM() посчитает ее как ноль. **Если в строке на первом месте стоит число, то SUM() выделит его из строки как число и посчитает.**

- `AVG()` считает среднее значение в столбце

    SELECT AVG(revenue)
    FROM game_events
Используйте AVG() с числовым типом данных. Если использовать AVG() со строковым типом данных, программа отработает, но результат работы программы будет не всегда очевидный. Например, если в строке нет чисел, то функция AVG() посчитает ее как ноль. Если в строке на первом месте стоит число, то AVG() выделит его из строки как число и посчитает.

- `MIN(`) и `MAX()` находят минимальное и максимальное значение в столбце соответственно.

    SELECT MIN(event_date), MAX(event_date)
    FROM game_events
Если использовать MIN() и MAX() со строковыми типами данных, то функции выберут минимальное и максимальное значение по алфавиту.

- `GROUP BY` - разбивает всю таблицу на множество секций, в каждой секции значения указанного столбца одинаковы. По своей сути группировка «схлопывает» множество строчек в одну.
    SELECT user_id, SUM(revenue)
    FROM game_events
    GROUP BY user_id
Этот запрос выведет сумму, которая поступила к нам от каждого пользователя за все время.
Как это работает?
<img width="1247" alt="image" src="https://github.com/luta-wolf/luta-wolf/assets/58044383/9af19ba8-034a-40bd-b349-69bb714d49c1">

1. FROM всегда работает в первую очередь, соответственно сначала мы получаем все данные из таблицы.

2. Следующим в нашем запросе срабатывает GROUP BY, это как раз и есть группировка. По сути группировка разбивает всю таблицу на множество секций, в каждой секции значения указанного столбца (в нашем случае user_id) одинаковы.

3. Далее в части SELECT вычисления внутри каждой из секций (в нашем случае user_id) будут производиться независимо. В SELECT у нас указано поле группировки — user_id, а также агрегатная функция, которая является указанием на то, что именно необходимо посчитать в рамках выделенной группы.

###
Задача посчитать количество уникальных пользователей за каждый день.

```SELECT event_date, COUNT(DISTINCT user_id)
FROM game_events
GROUP BY event_date
```
<img width="1262" alt="image" src="https://github.com/luta-wolf/luta-wolf/assets/58044383/cee6364a-eed8-4d15-8a84-2753669b9bf2">
После того, как с помощью `GROUP` BY был выделен каждый день, в каждом дне происходит подсчет уникальных пользователей, это происходит в момент работы `SELECT`.


## Pandas: фильтрация данных
    import pandas as pd

- `DataFrame` - тип данных, подобеный таблицам в привычном понимании. В нем есть и строки, и столбцы (как в SQL).
- `unique()` - метод, который выделит только уникальные записи (аналог DISTINCT в SQL)
    game_events_unique_users = game_events['user_id'].unique()
    print(game_events_unique_users)
- `nunique()` - метод, который подсчитывает количество уникальных значений в столбце.
    game_events_unique_users = game_events['user_id'].nunique()
    print(game_events_unique_users)

#### Фильтарация (аналог WHERE в SQL)
    my_game_events = game_events[game_events['event_name'] == 'app_first_launch']
    print(my_game_events)
По аналогии можно, например, так отфильтровать данные:
1) по дате: game_events[game_events['event_date'] == '2021-01-10'] - получаем все строки, где дата события '2021-01-10'
2) по названию уровня: game_events[game_events['level_name'] == 'level_03'] - получаем все строки, где название уровня 'level_03'
3) по стоимости внутриигровой покупки: game_events[game_events['revenue'] > 2] - получаем все строки, где выручка больше двух.

#### Агрегирующие методы для DataFrame
- `count()` - считает количество значений (не берет в расчет пустые значения)
- `sum()` - вычисляет сумму значений
- `max()` - выбирает максимальное значение
- `min()` -  выбирает минимальное значение
- `mean()` - считает среднее
- `median()` - считает медиану

### Продуктовые и маркетинговые метрики
- `Продуктовые и маркетинговые метрики` –  показатели, которые помогают компании анализировать успех своего продукта.
-  `Conversion Rate` (коэффициент конверсии) —  доля пользователей, которые совершили целевое действие, например, зарегистрировались, подписались на рассылку, оформили покупку.
- `LTV (Lifetime Value)` — вся прибыль от клиента за период, пока вы с ним работаете. Суть метрики — показать, оправданы ли затраты на привлечение и удержание такого клиента.С помощью LTV можно:

1. определить, какой тип клиентов приносит максимальную прибыль, а затем более целенаправленно проводить рекламную кампанию
2. посчитать, насколько быстро окупятся затраты
3. проанализировать эффективность маркетинговой стратегии и определить, через какой канал приходит больше клиентов, а следовательно, сократить затраты на неэффективную рекламу.
- `CAC` (Customer Acquisition Cost) — стоимость привлечения одного клиента. Эта метрика помогает выбрать наиболее результативный канал привлечения клиентов и правильно распределить бюджет. CAC считается так: расходы нужно поделить на количество пользователей.
- `AOV` (Average Order Value) – средний чек, то есть сумма, которую в среднем тратят клиенты. Средний чек показывает, какая покупательская способность у аудитории. С помощью этого показателя можно выделить группу клиентов, у которых AOV выше, что делает её выгоднее для бизнеса, и направить рекламную кампанию именно на эту группу. Средний чек считается так: сумму полученной выручки нужно поделить на количество заказов (покупок).
- `ARPU` (Average Revenue Per User) – средний доход с одного активного пользователя за период. ARPU рассчитывается как доход, деленный на количество пользователей. Период может быть любым. Mожно анализировать значение этого показателя за день, за месяц, за квартал и т.д., в зависимости от постановки задачи.
- `ARPPU` (Average Revenue Per Paying User) – средний доход с одного платящего пользователя за период.
Как видно из определения, отличие ARPPU заключается в том, что в расчёт попадают не все пользователи, а только те, кто совершал платежи в течение периода.
