## "Поколение Python": курс для начинающих
[Курс на Stepic](https://stepik.org/course/58852/syllabus) от [BEEGEEK](https://pygen.ru/), подкаст с [автором Тимуром Гуевым](https://mlpodcast.mave.digital/ep-44)
- Pep8 на [русском](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html)
- [Эмоджи](https://pypi.org/project/emoji/) в Python
- Официальный сайт таблицы символов [Unicode](https://home.unicode.org/)
<img width="898" alt="image" src="https://github.com/luta-wolf/Python_solved_tasks/assets/58044383/0aab3f42-1042-476e-954e-cad84455b48a">

# Манифест по изучению программирования
Текст написан по мотивам моего опыта: я работал 6 лет программистом в разных командах разработчиков, 10 лет преподавателем в школе, 3 года автором в школе онлайн курсов.

Мы привыкли к обучению по принципу: смотри сюда и повторяй за мной. Обычно так обучают в школах. Такой подход перестает работать классу к восьмому. Ученики задают себе вопрос: зачем делать то, что не приносит удовольствия? В школе пытаются «вбивать» знания в каждого, независимо от его желания. Но обучение неэффективно без главного условия: ученик должен принимать самое активное участие в получении знаний.

#### Освоить IT-профессию невозможно без тысяч часов самостоятельного решения задач.
Обучение после школы —  неважно, в колледже, вузе, на курсах или даже у личного ментора (обратите внимание!) — подразумевает по большей части самостоятельное освоение и проработку материала.

Роль преподавателя (ментора) сводится к следующему:

- систематизация учебной программы, построение плана: от простого к сложному;
- помощь при затруднениях;
- указание на ошибки;
- подпитывание мотивации;
- моральная поддержка.
Всю остальную работу учащийся выполняет сам.

#### Обучение — это на 80% самостоятельная работа.
Потенциально успешный программист мне виден уже после выполнения первых домашних заданий: его решения основаны не только на материале, который разбирали на занятии в группе, но и на дополнительных сведениях, найденных самостоятельно.

Хочу выделить 4 принципа изучения программирования, которые по моему опыту работают.

#### 1 В первую очередь тренируйте базовые навыки
В программировании (как, впрочем, и в других отраслях) существуют базовые вещи, и первое, на чем нужно сосредоточиться — доведение базовых навыков до автоматизма. Когда ваш мозг не расходует много времени на обращение с базовыми понятиями, вы способны действовать продуктивно и адекватно решать задачи. Азбуку нужно знать твердо, тогда скорость обучения и работы будет высокой. Каждый следующий уровень знаний ложится поверх предыдущего и содержит все меньше принципиально новой информации, поскольку опирается на усвоенные знания.

Именно поэтому наши курсы содержат так много задач.

#### 2 Пишите код
В памяти надежно сохраняется только то, что мы подкрепляем собственными действиями, опытом. Так устроен мозг. Когда читаем чужой код или смотрим видеолекцию, часто все настолько понятно, что кажется: “Зачем мне это повторять, ведь все ясно”. Это иллюзия! Стоит попытаться повторить логику, написать код своими руками, как тут же столкнемся с кучей сложностей и непонятных вещей, которые не удастся разрешить без подсказок. Копирование чужого кода тоже не способствует глубокому пониманию и усвоению навыка.

Нужно как можно больше разбираться с кодом и самостоятельно писать программы.,В идеале - работать над собственным проектом, пусть это будет даже калькулятор. Можно создать крутой калькулятор и при этом повторить (освежить в памяти) множество тем, начиная от переменных и заканчивая лямбда-функциями. И не старайтесь делать всё идеально, достаточно просто хорошо. Мы растем, и то, что сегодня хорошо, успеем в будущем сделать идеальным (если это кому-нибудь нужно).

Чтение книг и просмотр лекций - хорошо, но без использования теории на практике мы не учимся.

P.S. Я очень люблю читать книги и смотреть лекции.

#### 3 Занимайтесь регулярно
Рекомендую уделять учебе каждый день по 2-3 часа (можно и больше). Это полезнее, чем 10-часовой интенсив раз в неделю.
Нерегулярные занятия абсолютно неэффективны, потому что навыки не закрепляются, знания рассеиваются, про мотивацию и говорить не приходится.

Важно выработать привычку учиться постоянно.

#### 4 Вам должно быть непонятно
Звучит странно, правда? Если вам что-то непонятно и вы тупите, это абсолютно нормально. Не нужно в такой ситуации считать себя недостаточно умным и неспособным изучить программирование. Думаете Senior программисты не тупят? Еще как. Они могут не сразу что-то понять, но не сдаются и изучают вопрос глубже! Даже очень опытные, матерые программисты часто не могут разобраться с чем-то новым. Они не стесняются обращаться за помощью. Но! Здесь есть одно важное “но”. Спрашивать нужно только после того, как с десяток раз попытаетесь разрешить проблему сами.

Классический вопрос на форуме наших курсов: “Что не так с моей программой?” Открываю проблемный код, запускаю программу, сразу выдается ошибка с расшифровкой. Интересно, человек, который задал вопрос, пытался запустить СВОЮ программу? Явно нет. Такой подход не позволит стать хорошим программистом. Задавая вопрос на форуме или в комментариях, нужно уточнять, что конкретно вы уже предприняли для решения, какие ваши шаги оказались безуспешными.

Многие темы наших курсов — например, элементы функционального программирования, анонимные функции, функции высшего порядка, итераторы, генераторы — не самые простые вещи. Требуется время и труд, чтобы эта информация уложилась в голове.

Если кажется, что учиться программированию легко, значит, вы не учитесь.

### О себе
Если думаете, что мне было легко изучить программирование, то глубоко заблуждаетесь. Я стартовал достаточно поздно по меркам программистов, аж на первом курсе ВУЗа. С преподавателем повезло (Мария Макаренко, здрасте). Было тяжело, как сейчас помню, даже вложенные циклы понять, а про рекурсию вообще молчу. Однажды  поймал себя на мысли: “А может быть, не твое это - программирование? Ну математик и математик, раз рекурсию не можешь понять”. Но я не сдался, отложил непонятное в дальний ящик, и дальше изучал программирование. Когда в следующий раз вернулся к рекурсии, был приятно удивлен: понял как она работает и мог решить практически любую задачу на эту тему. Какой вывод? Не сдавайтесь! Если что-то непонятно, читайте книги, читайте интернет (в мое время информации было намного меньше, чем сейчас), пишите код, реализуйте проекты. Отложите сложное, чтобы рассмотреть еще раз позже, при этом работайте над собой, развивайтесь. Всегда можно вернуться с новыми знаниями, силами, умениями. Вы будете приятно удивлены. Поверьте мне.

И да, я начал изучать язык Python, когда писал “Поколение Python: курс для начинающих”. До этого моим языком был C#. Как видите, мне это не помешало создать лучший курс по Python (Stepik Awards 2020).

### Вывод
Никакой курс (даже наши курсы 😢) не сделают из вас программиста без самообразования. Курсы – лишь способ достижения этой цели. Они могут сделать путь к успеху удобнее и быстрее.

Цель образовательных курсов - сделать процесс обучения проще и эффективнее. Но никто в мире не сможет учиться за вас.

Тимур Гуев, автор курсов “Поколение Python”

## Дополнительные материалы
Схема для задания 9 из главы 4-3
  <img width="1798" alt="image" src="https://github.com/luta-wolf/weather_app/assets/58044383/c91d2867-78f3-49b2-8dcb-9be2e91efd79">

## Список функций модуля math
Список наиболее часто используемых функций модуля math:

#### Округления
- `int()`	Округляет число в сторону нуля
- `round(x)`	Округляет число `x` до ближайшего целого. Если дробная часть числа равна 0.5, то число округляется до ближайшего четного числа
- `round(x, n)`	Округляет число `x` до n знаков после точки
- `floor(x`)	Округляет число `x` вниз («пол»)
- `ceil(x)`	Округляет число `x` вверх («потолок»)
- `abs(x)`	Модуль числа `x` (абсолютная величина)
#### Корни, логарифмы, степени и факториал

- `sqrt(x)`	Квадратный корень числа `x`
- `pow(x, n)`	Возведение числа `x` в степень n
- `log(x)`	Натуральный логарифм числа `x`. Основание натурального логарифма равно числу e
- `log10(x)`	Десятичный логарифм числа `x`. Основание десятичного логарифма равно числу 10
- `log(x, b)`	Логарифм числа `x` по основанию b
- `factorial(n)`	Факториал натурального числа n

#### Тригонометрия
- `degrees(x)`	Преобразует угол `x`, заданный в радианах, в градусы
- `radians(x)`	Преобразует угол `x`, заданный в градусах, в радианы
- `cos(x)`	Косинус угла `x`, задаваемого в радианах
- `sin(x)`	Синус угла `x`, задаваемого в радианах
- `tan(x)`	Тангенс угла `x`, задаваемого в радианах
- `acos(x)`	Возвращает угол в радианах от 0 до π, `cos` которого равен `x`
- `asin(x)`	Возвращает угол в радианах от −π/2 до π/2 `sin` которого равен `x`
- `atan(x)`	Возвращает угол в радианах от −π/2 до π/2 `tan` которого равен `x`
- `atan2(y, x)`	Полярный угол (в радианах) точки с координатами (x, y)

#### Список констант модуля math
Модуль math предоставляет ряд встроенных математических констант:
- `pi` число π = 3.141592653589793
- `e` число e = 2.718281828459045


## Расширенные операторы присваивания
<img width="778" alt="image" src="https://github.com/luta-wolf/Python_solved_tasks/assets/58044383/029ad515-9fc3-4c14-b12e-032466f35156">

## Ревью кода
Ревью кода – проверка исходного кода программы с целью обнаружения и исправления ошибок и неточностей, которые остались незамеченными при начальной разработке.

В процессе ревью кода могут быть исправлены:
- фактические ошибки;
- производительность кода;
- читабельность кода и ошибки форматирования кода.
Целью ревью кода является улучшение качества программного кода и совершенствование навыков программиста.
<img width="624" alt="image" src="https://github.com/luta-wolf/luta-wolf/assets/58044383/eeca9b3d-409d-4f22-8254-1a07b58ef076">

### Фактические ошибки
К фактическим ошибкам в коде относятся ошибки из-за которых код может работать неверно. По сути, это ошибки относящиеся к алгоритму, который используется в программе для решения задачи.

Среди частых фактических ошибок встречаются:
- отсутствие начальной инициализации переменной;
- неправильная начальная инициализация переменной;
- отсутствие отступа (в Python блоки кода выделяются отступами);
- неправильные числовые граничные значения, например при использовании функции range();
- неправильные граничные сравнения (путаница с >, >= или <, <=);
- путаница логических операций or и and и т.д.

### Производительность кода
Под производительностью кода в простейшем случае можно подразумевать то, сколько времени программа тратит на решение задачи. При написании программы, программист должен думать над тем, сколько времени в худшем случае потребуется его программе для решения задачи.

### Читабельность кода
Следует помнить, что наш код должен легко читаться другими программистами. Чтобы этого достичь, следует придерживаться стандарта PEP 8. Обращайте внимание на следующие моменты:
- отступы и пробелы: используйте 4 пробела на один уровень отступа и никогда не смешивайте символы табуляции и пробелы;
- названия переменных: используйте говорящие названия для переменных (total, counter, product) и следуйте стилю lower_case_with_underscores (слова из маленьких букв с подчеркиваниями);
- пустые строки: дополнительные отступы пустыми строками могут быть изредка полезны для выделения группы логически связанных частей программы: инициализация переменных, основной алгоритм, завершающая проверка и т.д.;
- комментарии: комментарии должны являться законченными предложениями. И помните, комментарии, которые противоречат коду, хуже, чем отсутствие комментариев. Всегда исправляйте комментарии, если меняете код!

## Индексация строк
<img width="536" alt="image" src="https://github.com/luta-wolf/Python_solved_tasks/assets/58044383/304303eb-914f-4aaa-a669-a3b5cb1fbe23">

## Срезы строк
s = 'abcdefghij'
<img width="825" alt="image" src="https://github.com/luta-wolf/Python_solved_tasks/assets/58044383/2671923f-0016-49c2-b0bb-e2d8518aac13">
print(s[2:5])
print(s[0:6])
print(s[2:7])
<img width="701" alt="image" src="https://github.com/luta-wolf/Python_solved_tasks/assets/58044383/373f00dd-d2c0-4410-9509-ef6906bb2c66">
print(s[2:])
print(s[:7])
<img width="699" alt="image" src="https://github.com/luta-wolf/Python_solved_tasks/assets/58044383/20eedf1a-c5dc-4516-b72e-cfc1a9d9c188">
Срез s[:] возвращает исходную строку.
Удалить из строки последний символ можно при помощи среза s[:-1].

print(s[-9:-4])
print(s[-3:])
print(s[:-3])
<img width="727" alt="image" src="https://github.com/luta-wolf/Python_solved_tasks/assets/58044383/d92991c3-42ce-4132-9519-218a8d407d15">

### Шаг среза
Мы можем передать в срез третий необязательный параметр, который отвечает за шаг среза. К примеру, срез s[1:7:2] создаст строку bdf состоящую из каждого второго символа (индексы 1, 3, 5, правая граница не включена в срез).
<img width="755" alt="image" src="https://github.com/luta-wolf/Python_solved_tasks/assets/58044383/9e49afe7-95a9-4019-94a3-67f383dcad70">

### Отрицательный шаг среза
`s = 'abcdefghij'`
print(s[::-1]) - выводит строку в обратном порядке --> jihgfedcba

print(s[1:7:2]) --> bdf

print(s[3::2]) --> dfhj

print(s[:7:3]) --> adg

print(s[::2]) --> acegi

print(s[::-1]) --> jihgfedcba

print(s[::-2]) --> jhfdb

## Методы и функции
Методы строкового типа данных можно разделить на три группы:
- Конвертация регистра;
- Поиск и замена;
- Классификация символов.

### Конвертация регистра
- `capitalize()` - возвращает копию строки s, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр.
- `swapcase()` - возвращает копию строки s, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.
- `title()` возвращает копию строки s, в которой первый символ каждого слова переводится в верхний регистр.
- `lower()` возвращает копию строки s, в которой все символы имеют нижний регистр.
- `upper()` возвращает копию строки s, в которой все символы имеют верхний регистр.

### Поиск и замена
- `count(<sub>, <start>, <end>)` считает количество непересекающихся вхождений подстроки <sub> в исходную строку s

    s = 'foo goo moo'

    print(s.count('oo'))        --> 3

    print(s.count('oo', 0, 8))  --> 2

- `startswith(<suffix>, <start>, <end>)` определяет начинается ли исходная строка s подстрокой <suffix>. Если исходная строка начинается с подстроки <suffix>,метод возвращает значение True, а если нет, то  False.

s = 'foobar'

print(s.startswith('foo'))  --> True

print(s.startswith('baz'))  --> False

- `endswith(<suffix>, <start>, <end>)` определяет оканчивается ли исходная строка s подстрокой <suffix>. Метод возвращает значение True если исходная строка оканчивается на подстроку <suffix> и False в противном случае.

s = 'foobar'

print(s.endswith('bar'))  --> True

print(s.endswith('baz'))  --> False

- `find(<sub>, <start>, <end>)` находит индекс первого вхождения подстроки <sub> в исходной строке s. Если строка s не содержит подстроки <sub>, то метод возвращает значение -1. Мы можем использовать данный метод наравне с оператором in для проверки: содержит ли заданная строка некоторую подстроку или нет.
- `rfind(<sub>, <start>, <end>)` идентичен методу find(<sub>, <start>, <end>), за тем исключением, что он ищет первое вхождение подстроки <sub> начиная с конца строки s.

s = 'foo bar foo baz foo qux'

print(s.find('foo'))  --> 0

print(s.find('bar'))  --> 4

print(s.find('qu')) --> 20

print(s.find('python')) --> -1

- `index(<sub>, <start>, <end>)` идентичен методу find(<sub>, <start>, <end>), за тем исключением, что он вызывает ошибку  ValueError: substring not found во время выполнения программы, если подстрока <sub> не найдена.

- `rindex(<sub>, <start>, <end>)` идентичен методу index(<sub>, <start>, <end>), за тем исключением, что он ищет первое вхождение подстроки <sub> начиная с конца строки s.

- `strip()` возвращает копию строки s у которой удалены все пробелы стоящие в начале и конце строки.

s = '     foo bar foo baz foo qux      '

print(s.lstrip()) --> 'foo bar foo baz foo qux'

- `rstrip()` возвращает копию строки s у которой удалены все пробелы стоящие в конце строки.

s = '      foo bar foo baz foo qux      '

print(s.rstrip()) --> '     foo bar foo baz foo qux'

- `replace(<old>, <new>, <count>)` ) возвращает копию s со всеми вхождениями подстроки <old>, замененными на <new>. <count> необязательный. Число, указывающее, сколько вхождений старого значения вы хотите заменить. По умолчанию все вхождения.

s = 'foo bar foo baz foo qux'

print(s.replace('foo', 'grault')) --> "grault bar grault baz grault qux"

Метод replace() может принимать опциональный третий аргумент <count>,  который определяет количество замен.

s = 'foo bar foo baz foo qux'

print(s.replace('foo', 'grault', 2))  --> "grault bar grault baz foo qux"


## Классификация символов
- `isalnum()` определяет, состоит ли исходная строка из буквенно-цифровых символов. Метод возвращает значение True если исходная строка является непустой и состоит только из буквенно-цифровых символов и False в противном случае.

s1 = 'abc123'

s2 = 'abc$*123'

s3 = ''

print(s1.isalnum()) --> True

print(s2.isalnum()) --> False

print(s3.isalnum()) --> False

- `isalpha()` определяет, состоит ли исходная строка из буквенных символов. Метод возвращает значение True если исходная строка является непустой и состоит только из буквенных символов и False в противном случае.

s1 = 'ABCabc'

s2 = 'abc123'

s3 = ''

print(s1.isalpha()) --> True

print(s2.isalpha()) --> False

print(s3.isalpha()) --> False

- `isdigit()` определяет, состоит ли исходная строка только из цифровых символов. Метод возвращает значение True если исходная строка является непустой и состоит только из цифровых символов и False в противном случае.

s1 = '1234567'

s2 = 'abc123'

s3 = ''

print(s1.isdigit()) --> True

print(s2.isdigit()) --> False

print(s3.isdigit()) --> False

- `islower()` определяет, являются ли все буквенные символы исходной строки строчными (имеют нижний регистр). Метод возвращает значение True если все буквенные символы исходной строки являются строчными и False в противном случае. Все неалфавитные символы игнорируются!

s1 = 'abc'

s2 = 'abc1$d'

s3 = 'Abc1$D'

print(s1.islower()) --> True

print(s2.islower()) --> True

print(s3.islower()) --> False

- `isupper()` определяет, являются ли все буквенные символы исходной строки заглавными (имеют верхний регистр). Метод возвращает значение True если все буквенные символы исходной строки являются заглавными и False в противном случае. Все неалфавитные символы игнорируются!

s1 = 'ABC'

s2 = 'ABC1$D'

s3 = 'Abc1$D'

print(s1.isupper()) --> True

print(s2.isupper()) --> True

print(s3.isupper()) --> False

- `isspace()` определяет, состоит ли исходная строка только из пробельных символов. Метод возвращает значение True если строка состоит только из пробельных символов и False в противном случае.

s1 = '       '

s2 = 'abc1$d'

print(s1.isspace()) --> True

print(s2.isspace()) --> False

## ASCII table
<img width="1056" alt="image" src="https://github.com/luta-wolf/pre-interview_tests/assets/58044383/1f59c4c4-094b-4804-b686-69fbad999688">
ASCII (American Standard Code for Information Interchange – американский стандартный код обмена информацией).
UTF (Unicode transformation format) - Формат преобразования Юникод.

### Функция ord
- `ord` позволяет определить код некоторого символа в таблице символов Unicode. Аргументом данной функции является одиночный символ.Обратите внимание, что функция ord принимает именно одиночный символ. Если попытаться передать строку, содержащую более одного символа. (Название функции ord происходит от английского слова order — порядок).

num1 = ord('A')

num2 = ord('B')

num3 = ord('a')

print(num1, num2, num3) --> 65 66 97

## Функция chr
- `chr` позволяет определить по коду символа сам символ. Аргументом данной функции является численный код.(Название функции chr происходит от английского слова char — символ.)

chr1 = chr(65)

chr2 = chr(75)

chr3 = chr(110)

print(chr1, chr2, chr3) --> A K n
